//! Provider validation tests for SQLite
//!
//! This test file validates the SQLite provider using the reusable
//! provider validation test suite from `duroxide::provider_validations`.
//!
//! These tests automatically enable the `provider-test` feature when running
//! tests within the duroxide repository.

#[cfg(feature = "provider-test")]
mod tests {
    use duroxide::provider_validations::{
        ProviderFactory,
        // Bulk deletion tests
        bulk_deletion::{
            test_delete_instance_bulk_cascades_to_children, test_delete_instance_bulk_completed_before_filter,
            test_delete_instance_bulk_filter_combinations, test_delete_instance_bulk_safety_and_limits,
        },
        // Deletion tests
        deletion::{
            test_cascade_delete_hierarchy, test_delete_cleans_queues_and_locks, test_delete_get_instance_tree,
            test_delete_get_parent_id, test_delete_instances_atomic, test_delete_instances_atomic_force,
            test_delete_instances_atomic_orphan_detection, test_delete_nonexistent_instance,
            test_delete_running_rejected_force_succeeds, test_delete_terminal_instances,
            test_force_delete_prevents_ack_recreation, test_list_children,
        },
        // Long polling tests
        long_polling::{
            test_fetch_respects_timeout_upper_bound, test_short_poll_returns_immediately,
            test_short_poll_work_item_returns_immediately,
        },
        // Poison message tests
        poison_message::{
            abandon_orchestration_item_ignore_attempt_decrements, abandon_work_item_ignore_attempt_decrements,
            attempt_count_is_per_message, ignore_attempt_never_goes_negative, max_attempt_count_across_message_batch,
            orchestration_attempt_count_increments_on_refetch, orchestration_attempt_count_starts_at_one,
            worker_attempt_count_increments_on_lock_expiry, worker_attempt_count_starts_at_one,
        },
        // Prune tests
        prune::{test_prune_bulk, test_prune_options_combinations, test_prune_safety},
        test_abandon_releases_lock_immediately,
        test_abandon_work_item_releases_lock,
        test_abandon_work_item_with_delay,
        test_ack_only_affects_locked_messages,
        // Cancellation tests
        test_ack_work_item_fails_when_entry_deleted,
        test_ack_work_item_none_deletes_without_enqueue,
        // Atomicity tests
        test_atomicity_failure_rollback,
        test_batch_cancellation_deletes_multiple_activities,
        test_cancelled_activities_deleted_from_worker_queue,
        test_cancelling_nonexistent_activities_is_idempotent,
        test_completions_arriving_during_lock_blocked,
        test_concurrent_ack_prevention,
        test_concurrent_instance_fetching,
        test_concurrent_lock_attempts_respect_expiration,
        test_continue_as_new_creates_new_execution,
        test_corrupted_serialization_data,
        test_cross_instance_lock_isolation,
        test_duplicate_event_id_rejection,
        // Instance locking tests
        test_exclusive_instance_lock,
        test_execution_history_persistence,
        test_execution_id_sequencing,
        // Multi-execution tests
        test_execution_isolation,
        test_fetch_returns_missing_state_when_instance_deleted,
        test_fetch_returns_running_state_for_active_orchestration,
        test_fetch_returns_terminal_state_when_orchestration_completed,
        test_fetch_returns_terminal_state_when_orchestration_continued_as_new,
        test_fetch_returns_terminal_state_when_orchestration_failed,
        test_get_execution_info,
        test_get_instance_info,
        test_get_queue_depths,
        test_get_system_metrics,
        // Instance creation tests
        test_instance_creation_via_metadata,
        // Error handling tests
        test_invalid_lock_token_on_ack,
        test_invalid_lock_token_rejection,
        test_latest_execution_detection,
        test_list_executions,
        // Management tests
        test_list_instances,
        test_list_instances_by_status,
        test_lock_expiration_during_ack,
        // Lock expiration tests
        test_lock_expires_after_timeout,
        test_lock_released_only_on_successful_ack,
        test_lock_renewal_on_ack,
        test_lock_token_uniqueness,
        test_lost_lock_token_handling,
        test_message_tagging_during_lock,
        test_missing_instance_metadata,
        test_multi_operation_atomic_ack,
        test_multi_threaded_lock_contention,
        test_multi_threaded_lock_expiration_recovery,
        test_multi_threaded_no_duplicate_processing,
        test_no_instance_creation_on_enqueue,
        test_null_version_handling,
        test_renew_fails_when_entry_deleted,
        test_renew_returns_missing_when_instance_deleted,
        test_renew_returns_running_when_orchestration_active,
        test_renew_returns_terminal_when_orchestration_completed,
        test_sub_orchestration_instance_creation,
        test_timer_delayed_visibility,
        test_worker_ack_atomicity,
        test_worker_delayed_visibility_skips_future_items,
        test_worker_item_immediate_visibility,
        // Worker lock renewal tests
        test_worker_lock_renewal_after_ack,
        test_worker_lock_renewal_after_expiration,
        test_worker_lock_renewal_extends_timeout,
        test_worker_lock_renewal_invalid_token,
        test_worker_lock_renewal_success,
        test_worker_peek_lock_semantics,
        // Queue semantics tests
        test_worker_queue_fifo_ordering,
    };
    use duroxide::providers::Provider;
    use duroxide::providers::sqlite::SqliteProvider;
    use std::sync::Arc;
    use std::time::Duration;

    const TEST_LOCK_TIMEOUT: Duration = Duration::from_millis(1000);

    struct SqliteTestFactory;

    #[async_trait::async_trait]
    impl ProviderFactory for SqliteTestFactory {
        async fn create_provider(&self) -> Arc<dyn Provider> {
            // Lock timeout is now configured via RuntimeOptions, not SqliteOptions
            Arc::new(SqliteProvider::new_in_memory().await.unwrap())
        }

        fn lock_timeout(&self) -> Duration {
            TEST_LOCK_TIMEOUT
        }
    }

    // Atomicity tests
    #[tokio::test]
    async fn test_sqlite_atomicity_failure_rollback() {
        test_atomicity_failure_rollback(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_multi_operation_atomic_ack() {
        test_multi_operation_atomic_ack(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_lock_released_only_on_successful_ack() {
        test_lock_released_only_on_successful_ack(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_concurrent_ack_prevention() {
        test_concurrent_ack_prevention(&SqliteTestFactory).await;
    }

    // Error handling tests
    #[tokio::test]
    async fn test_sqlite_invalid_lock_token_on_ack() {
        test_invalid_lock_token_on_ack(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_duplicate_event_id_rejection() {
        test_duplicate_event_id_rejection(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_missing_instance_metadata() {
        test_missing_instance_metadata(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_corrupted_serialization_data() {
        test_corrupted_serialization_data(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_lock_expiration_during_ack() {
        test_lock_expiration_during_ack(&SqliteTestFactory).await;
    }

    // Instance locking tests
    #[tokio::test]
    async fn test_sqlite_exclusive_instance_lock() {
        test_exclusive_instance_lock(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_lock_token_uniqueness() {
        test_lock_token_uniqueness(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_invalid_lock_token_rejection() {
        test_invalid_lock_token_rejection(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_concurrent_instance_fetching() {
        test_concurrent_instance_fetching(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_completions_arriving_during_lock_blocked() {
        test_completions_arriving_during_lock_blocked(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_cross_instance_lock_isolation() {
        test_cross_instance_lock_isolation(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_message_tagging_during_lock() {
        test_message_tagging_during_lock(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_ack_only_affects_locked_messages() {
        test_ack_only_affects_locked_messages(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_multi_threaded_lock_contention() {
        test_multi_threaded_lock_contention(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_multi_threaded_no_duplicate_processing() {
        test_multi_threaded_no_duplicate_processing(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_multi_threaded_lock_expiration_recovery() {
        test_multi_threaded_lock_expiration_recovery(&SqliteTestFactory).await;
    }

    // Lock expiration tests
    #[tokio::test]
    async fn test_sqlite_lock_expires_after_timeout() {
        test_lock_expires_after_timeout(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_abandon_releases_lock_immediately() {
        test_abandon_releases_lock_immediately(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_lock_renewal_on_ack() {
        test_lock_renewal_on_ack(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_concurrent_lock_attempts_respect_expiration() {
        test_concurrent_lock_attempts_respect_expiration(&SqliteTestFactory).await;
    }

    // Multi-execution tests
    #[tokio::test]
    async fn test_sqlite_execution_isolation() {
        test_execution_isolation(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_latest_execution_detection() {
        test_latest_execution_detection(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_execution_id_sequencing() {
        test_execution_id_sequencing(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_continue_as_new_creates_new_execution() {
        test_continue_as_new_creates_new_execution(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_execution_history_persistence() {
        test_execution_history_persistence(&SqliteTestFactory).await;
    }

    // Queue semantics tests
    #[tokio::test]
    async fn test_sqlite_worker_queue_fifo_ordering() {
        test_worker_queue_fifo_ordering(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_worker_peek_lock_semantics() {
        test_worker_peek_lock_semantics(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_worker_ack_atomicity() {
        test_worker_ack_atomicity(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_timer_delayed_visibility() {
        test_timer_delayed_visibility(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_lost_lock_token_handling() {
        test_lost_lock_token_handling(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_worker_item_immediate_visibility() {
        test_worker_item_immediate_visibility(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_worker_delayed_visibility_skips_future_items() {
        test_worker_delayed_visibility_skips_future_items(&SqliteTestFactory).await;
    }
    // Management tests
    #[tokio::test]
    async fn test_sqlite_list_instances() {
        test_list_instances(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_list_instances_by_status() {
        test_list_instances_by_status(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_list_executions() {
        test_list_executions(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_get_instance_info() {
        test_get_instance_info(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_get_execution_info() {
        test_get_execution_info(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_get_system_metrics() {
        test_get_system_metrics(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_get_queue_depths() {
        test_get_queue_depths(&SqliteTestFactory).await;
    }

    // Instance creation tests
    #[tokio::test]
    async fn test_sqlite_instance_creation_via_metadata() {
        test_instance_creation_via_metadata(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_no_instance_creation_on_enqueue() {
        test_no_instance_creation_on_enqueue(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_null_version_handling() {
        test_null_version_handling(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_sub_orchestration_instance_creation() {
        test_sub_orchestration_instance_creation(&SqliteTestFactory).await;
    }

    // Long polling tests (SQLite uses short polling)
    #[tokio::test]
    async fn test_sqlite_short_poll_returns_immediately() {
        let provider = SqliteTestFactory.create_provider().await;
        test_short_poll_returns_immediately(&*provider).await;
    }

    #[tokio::test]
    async fn test_sqlite_short_poll_work_item_returns_immediately() {
        let provider = SqliteTestFactory.create_provider().await;
        test_short_poll_work_item_returns_immediately(&*provider).await;
    }

    #[tokio::test]
    async fn test_sqlite_fetch_respects_timeout_upper_bound() {
        let provider = SqliteTestFactory.create_provider().await;
        test_fetch_respects_timeout_upper_bound(&*provider).await;
    }

    // Poison message tests
    #[tokio::test]
    async fn test_sqlite_orchestration_attempt_count_starts_at_one() {
        orchestration_attempt_count_starts_at_one(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_orchestration_attempt_count_increments_on_refetch() {
        orchestration_attempt_count_increments_on_refetch(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_worker_attempt_count_starts_at_one() {
        worker_attempt_count_starts_at_one(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_worker_attempt_count_increments_on_lock_expiry() {
        worker_attempt_count_increments_on_lock_expiry(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_attempt_count_is_per_message() {
        attempt_count_is_per_message(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_abandon_work_item_ignore_attempt_decrements() {
        abandon_work_item_ignore_attempt_decrements(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_abandon_orchestration_item_ignore_attempt_decrements() {
        abandon_orchestration_item_ignore_attempt_decrements(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_ignore_attempt_never_goes_negative() {
        ignore_attempt_never_goes_negative(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_max_attempt_count_across_message_batch() {
        max_attempt_count_across_message_batch(&SqliteTestFactory).await;
    }

    // abandon_work_item tests
    #[tokio::test]
    async fn test_sqlite_abandon_work_item_releases_lock() {
        test_abandon_work_item_releases_lock(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_abandon_work_item_with_delay() {
        test_abandon_work_item_with_delay(&SqliteTestFactory).await;
    }

    // Cancellation tests (activity cancellation support)
    #[tokio::test]
    async fn test_sqlite_fetch_returns_running_state_for_active_orchestration() {
        test_fetch_returns_running_state_for_active_orchestration(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_fetch_returns_terminal_state_when_orchestration_completed() {
        test_fetch_returns_terminal_state_when_orchestration_completed(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_fetch_returns_terminal_state_when_orchestration_failed() {
        test_fetch_returns_terminal_state_when_orchestration_failed(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_fetch_returns_terminal_state_when_orchestration_continued_as_new() {
        test_fetch_returns_terminal_state_when_orchestration_continued_as_new(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_fetch_returns_missing_state_when_instance_deleted() {
        test_fetch_returns_missing_state_when_instance_deleted(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_renew_returns_running_when_orchestration_active() {
        test_renew_returns_running_when_orchestration_active(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_renew_returns_terminal_when_orchestration_completed() {
        test_renew_returns_terminal_when_orchestration_completed(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_renew_returns_missing_when_instance_deleted() {
        test_renew_returns_missing_when_instance_deleted(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_ack_work_item_none_deletes_without_enqueue() {
        test_ack_work_item_none_deletes_without_enqueue(&SqliteTestFactory).await;
    }

    // Lock-stealing activity cancellation tests
    #[tokio::test]
    async fn test_sqlite_cancelled_activities_deleted_from_worker_queue() {
        test_cancelled_activities_deleted_from_worker_queue(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_ack_work_item_fails_when_entry_deleted() {
        test_ack_work_item_fails_when_entry_deleted(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_renew_fails_when_entry_deleted() {
        test_renew_fails_when_entry_deleted(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_cancelling_nonexistent_activities_is_idempotent() {
        test_cancelling_nonexistent_activities_is_idempotent(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_batch_cancellation_deletes_multiple_activities() {
        test_batch_cancellation_deletes_multiple_activities(&SqliteTestFactory).await;
    }

    // Deletion tests
    #[tokio::test]
    async fn test_sqlite_delete_terminal_instances() {
        test_delete_terminal_instances(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_delete_running_rejected_force_succeeds() {
        test_delete_running_rejected_force_succeeds(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_delete_nonexistent_instance() {
        test_delete_nonexistent_instance(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_delete_cleans_queues_and_locks() {
        test_delete_cleans_queues_and_locks(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_cascade_delete_hierarchy() {
        test_cascade_delete_hierarchy(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_force_delete_prevents_ack_recreation() {
        test_force_delete_prevents_ack_recreation(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_list_children() {
        test_list_children(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_delete_get_parent_id() {
        test_delete_get_parent_id(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_delete_get_instance_tree() {
        test_delete_get_instance_tree(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_delete_instances_atomic() {
        test_delete_instances_atomic(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_delete_instances_atomic_force() {
        test_delete_instances_atomic_force(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_delete_instances_atomic_orphan_detection() {
        test_delete_instances_atomic_orphan_detection(&SqliteTestFactory).await;
    }

    // Worker lock renewal tests
    #[tokio::test]
    async fn test_sqlite_worker_lock_renewal_success() {
        test_worker_lock_renewal_success(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_worker_lock_renewal_invalid_token() {
        test_worker_lock_renewal_invalid_token(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_worker_lock_renewal_after_expiration() {
        test_worker_lock_renewal_after_expiration(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_worker_lock_renewal_extends_timeout() {
        test_worker_lock_renewal_extends_timeout(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_worker_lock_renewal_after_ack() {
        test_worker_lock_renewal_after_ack(&SqliteTestFactory).await;
    }

    // Prune tests
    #[tokio::test]
    async fn test_sqlite_prune_options_combinations() {
        test_prune_options_combinations(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_prune_safety() {
        test_prune_safety(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_prune_bulk() {
        test_prune_bulk(&SqliteTestFactory).await;
    }

    // Bulk deletion tests
    #[tokio::test]
    async fn test_sqlite_delete_instance_bulk_filter_combinations() {
        test_delete_instance_bulk_filter_combinations(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_delete_instance_bulk_safety_and_limits() {
        test_delete_instance_bulk_safety_and_limits(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_delete_instance_bulk_completed_before_filter() {
        test_delete_instance_bulk_completed_before_filter(&SqliteTestFactory).await;
    }

    #[tokio::test]
    async fn test_sqlite_delete_instance_bulk_cascades_to_children() {
        test_delete_instance_bulk_cascades_to_children(&SqliteTestFactory).await;
    }
}
