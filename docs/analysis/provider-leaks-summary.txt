╔══════════════════════════════════════════════════════════════════════════════╗
║                   PROVIDER ABSTRACTION LEAK ANALYSIS                         ║
╚══════════════════════════════════════════════════════════════════════════════╝

PRINCIPLE VIOLATED:
"Provider shouldn't know anything about orchestration semantics apart from the 
fact that some things need to be transactional"

═══════════════════════════════════════════════════════════════════════════════

🔴 LEAK #1: Event Content Inspection (CRITICAL)
═══════════════════════════════════════════════════════════════════════════════
File: src/providers/sqlite.rs:740-811

Provider Code:
    for event in &history_delta {
        match event {
            Event::OrchestrationCompleted { output, .. } => {
                UPDATE executions SET status='Completed', output=?
            }
            Event::OrchestrationFailed { error, .. } => {
                UPDATE executions SET status='Failed', output=?
            }
            Event::OrchestrationContinuedAsNew { input, .. } => {
                UPDATE executions SET status='ContinuedAsNew', output=?
            }
        }
    }

PROBLEM:
✗ Provider pattern-matches on Event::OrchestrationCompleted
✗ Provider understands "completion" semantics
✗ Provider extracts output/error/input from events
✗ Provider decides status values ('Completed', 'Failed', etc.)

SHOULD BE:
✓ Runtime inspects history_delta
✓ Runtime provides: [(key="status", value="Completed"), (key="output", value=...)]
✓ Provider blindly stores key-value pairs

═══════════════════════════════════════════════════════════════════════════════

🔴 LEAK #2: ContinueAsNew Logic (CRITICAL)
═══════════════════════════════════════════════════════════════════════════════
File: src/providers/sqlite.rs:825-854

Provider Code:
    let has_continue_as_new = orchestrator_items.iter()
        .any(|item| matches!(item, WorkItem::ContinueAsNew { .. }));
    
    if has_continue_as_new {
        let next_exec_id = execution_id + 1;
        INSERT INTO executions (instance_id, execution_id, status)
        UPDATE instances SET current_execution_id = ?
    }

PROBLEM:
✗ Provider knows about ContinueAsNew semantics
✗ Provider manages execution lifecycle
✗ Provider increments execution IDs
✗ Provider updates current_execution_id pointer

SHOULD BE:
✓ Runtime determines: need_new_partition=true, partition_id=2
✓ Runtime tells provider: "create partition 2 for instance X"
✓ Provider executes without understanding WHY

═══════════════════════════════════════════════════════════════════════════════

🔴 LEAK #3: Event Creation (CRITICAL)
═══════════════════════════════════════════════════════════════════════════════
File: src/providers/sqlite.rs:1325-1333, src/providers/mod.rs:196-204

Provider Code:
    async fn create_new_execution(...) -> Result<u64, String> {
        let start_event = Event::OrchestrationStarted {
            event_id: 1,
            name: orchestration.to_string(),
            version: version.to_string(),
            input: input.to_string(),
            parent_instance, parent_id,
        };
        self.append_history_in_tx(..., vec![start_event])
    }

PROBLEM:
✗ Provider constructs Event::OrchestrationStarted
✗ Provider knows event structure
✗ Provider trait has create_new_execution method

SHOULD BE:
✓ Remove create_new_execution from Provider trait
✓ Runtime creates ALL events
✓ Provider only has append_events()

═══════════════════════════════════════════════════════════════════════════════

🟡 LEAK #4: Orchestration Metadata (MEDIUM)
═══════════════════════════════════════════════════════════════════════════════
File: src/providers/mod.rs:5-13

Provider Interface:
    pub struct OrchestrationItem {
        pub instance: String,
        pub orchestration_name: String,  // ← Orchestration-specific!
        pub execution_id: u64,           // ← Might be ok (partition ID)
        pub version: String,             // ← Orchestration-specific!
        pub history: Vec<Event>,
        pub messages: Vec<WorkItem>,
        pub lock_token: String,
    }

PROBLEM:
✗ orchestration_name leaks into provider interface
✗ version is orchestration-specific
✗ Provider must populate these fields

SHOULD BE:
✓ OrchestrationItem { instance, partition_id, history, messages, lock_token }
✓ Runtime derives name/version from history if needed
✓ Or: metadata: HashMap<String, String> for any app-specific data

═══════════════════════════════════════════════════════════════════════════════

🟡 LEAK #5: Instance Metadata Table (MEDIUM)
═══════════════════════════════════════════════════════════════════════════════
File: src/providers/sqlite.rs:238-246

Schema:
    CREATE TABLE instances (
        instance_id TEXT PRIMARY KEY,
        orchestration_name TEXT,      // ← Orchestration concept
        orchestration_version TEXT,   // ← Orchestration concept
        current_execution_id INTEGER, // ← Orchestration concept
        status TEXT,                  // ← Orchestration concept
        ...
    );

PROBLEM:
✗ Table is filled with orchestration-specific columns
✗ Provider maintains orchestration registry

SHOULD BE:
✓ Generic: CREATE TABLE partitions (entity_id, partition_id, metadata JSONB)
✓ Or: Runtime manages metadata separately
✓ Provider just does: "entity X has partitions [1,2,3]"

═══════════════════════════════════════════════════════════════════════════════

🟢 LEAK #6: WorkItem Instance Extraction (MINOR)
═══════════════════════════════════════════════════════════════════════════════
File: src/providers/sqlite.rs:24-35, 909-920

Provider Code:
    let instance = match &item {
        WorkItem::StartOrchestration { instance, .. } => instance,
        WorkItem::ActivityCompleted { instance, .. } => instance,
        // ... 11+ variants
    };

PROBLEM:
✗ Provider must know all WorkItem structures
✗ Pattern matching on 11+ variants

SHOULD BE:
✓ WorkItem has instance() method
✓ Or: All WorkItems have common instance field
✓ Provider doesn't pattern match

═══════════════════════════════════════════════════════════════════════════════

SUMMARY OF VIOLATIONS
═══════════════════════════════════════════════════════════════════════════════

Provider SHOULD only know:
  ✓ How to store opaque events
  ✓ How to enqueue/dequeue messages
  ✓ How to provide ACID guarantees
  ✓ How to implement peek-lock semantics

Provider SHOULD NOT know:
  ✗ What "OrchestrationCompleted" means (knows it)
  ✗ How to create orchestration events (does it)
  ✗ When to create new executions (decides it)
  ✗ What status values mean (uses them)
  ✗ Orchestration names and versions (stores and inspects)

═══════════════════════════════════════════════════════════════════════════════

RECOMMENDED IMMEDIATE FIX
═══════════════════════════════════════════════════════════════════════════════

Move event inspection from Provider to Runtime:

BEFORE (in Provider):
    for event in &history_delta {
        match event {
            Event::OrchestrationCompleted { output, .. } => update_status()
        }
    }

AFTER (in Runtime):
    let metadata = self.compute_execution_metadata(&history_delta);
    provider.ack_with_metadata(token, history, items, metadata);
    
(in Provider):
    async fn ack_with_metadata(metadata: HashMap<String, String>) {
        for (key, value) in metadata {
            UPDATE metadata SET value WHERE key
        }
    }

This single change eliminates the biggest abstraction leak with minimal code changes.

═══════════════════════════════════════════════════════════════════════════════
