â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   PROVIDER ABSTRACTION LEAK ANALYSIS                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PRINCIPLE VIOLATED:
"Provider shouldn't know anything about orchestration semantics apart from the 
fact that some things need to be transactional"

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”´ LEAK #1: Event Content Inspection (CRITICAL)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
File: src/providers/sqlite.rs:740-811

Provider Code:
    for event in &history_delta {
        match event {
            Event::OrchestrationCompleted { output, .. } => {
                UPDATE executions SET status='Completed', output=?
            }
            Event::OrchestrationFailed { error, .. } => {
                UPDATE executions SET status='Failed', output=?
            }
            Event::OrchestrationContinuedAsNew { input, .. } => {
                UPDATE executions SET status='ContinuedAsNew', output=?
            }
        }
    }

PROBLEM:
âœ— Provider pattern-matches on Event::OrchestrationCompleted
âœ— Provider understands "completion" semantics
âœ— Provider extracts output/error/input from events
âœ— Provider decides status values ('Completed', 'Failed', etc.)

SHOULD BE:
âœ“ Runtime inspects history_delta
âœ“ Runtime provides: [(key="status", value="Completed"), (key="output", value=...)]
âœ“ Provider blindly stores key-value pairs

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”´ LEAK #2: ContinueAsNew Logic (CRITICAL)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
File: src/providers/sqlite.rs:825-854

Provider Code:
    let has_continue_as_new = orchestrator_items.iter()
        .any(|item| matches!(item, WorkItem::ContinueAsNew { .. }));
    
    if has_continue_as_new {
        let next_exec_id = execution_id + 1;
        INSERT INTO executions (instance_id, execution_id, status)
        UPDATE instances SET current_execution_id = ?
    }

PROBLEM:
âœ— Provider knows about ContinueAsNew semantics
âœ— Provider manages execution lifecycle
âœ— Provider increments execution IDs
âœ— Provider updates current_execution_id pointer

SHOULD BE:
âœ“ Runtime determines: need_new_partition=true, partition_id=2
âœ“ Runtime tells provider: "create partition 2 for instance X"
âœ“ Provider executes without understanding WHY

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”´ LEAK #3: Event Creation (CRITICAL)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
File: src/providers/sqlite.rs:1325-1333, src/providers/mod.rs:196-204

Provider Code:
    async fn create_new_execution(...) -> Result<u64, String> {
        let start_event = Event::OrchestrationStarted {
            event_id: 1,
            name: orchestration.to_string(),
            version: version.to_string(),
            input: input.to_string(),
            parent_instance, parent_id,
        };
        self.append_history_in_tx(..., vec![start_event])
    }

PROBLEM:
âœ— Provider constructs Event::OrchestrationStarted
âœ— Provider knows event structure
âœ— Provider trait has create_new_execution method

SHOULD BE:
âœ“ Remove create_new_execution from Provider trait
âœ“ Runtime creates ALL events
âœ“ Provider only has append_events()

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸŸ¡ LEAK #4: Orchestration Metadata (MEDIUM)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
File: src/providers/mod.rs:5-13

Provider Interface:
    pub struct OrchestrationItem {
        pub instance: String,
        pub orchestration_name: String,  // â† Orchestration-specific!
        pub execution_id: u64,           // â† Might be ok (partition ID)
        pub version: String,             // â† Orchestration-specific!
        pub history: Vec<Event>,
        pub messages: Vec<WorkItem>,
        pub lock_token: String,
    }

PROBLEM:
âœ— orchestration_name leaks into provider interface
âœ— version is orchestration-specific
âœ— Provider must populate these fields

SHOULD BE:
âœ“ OrchestrationItem { instance, partition_id, history, messages, lock_token }
âœ“ Runtime derives name/version from history if needed
âœ“ Or: metadata: HashMap<String, String> for any app-specific data

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸŸ¡ LEAK #5: Instance Metadata Table (MEDIUM)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
File: src/providers/sqlite.rs:238-246

Schema:
    CREATE TABLE instances (
        instance_id TEXT PRIMARY KEY,
        orchestration_name TEXT,      // â† Orchestration concept
        orchestration_version TEXT,   // â† Orchestration concept
        current_execution_id INTEGER, // â† Orchestration concept
        status TEXT,                  // â† Orchestration concept
        ...
    );

PROBLEM:
âœ— Table is filled with orchestration-specific columns
âœ— Provider maintains orchestration registry

SHOULD BE:
âœ“ Generic: CREATE TABLE partitions (entity_id, partition_id, metadata JSONB)
âœ“ Or: Runtime manages metadata separately
âœ“ Provider just does: "entity X has partitions [1,2,3]"

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸŸ¢ LEAK #6: WorkItem Instance Extraction (MINOR)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
File: src/providers/sqlite.rs:24-35, 909-920

Provider Code:
    let instance = match &item {
        WorkItem::StartOrchestration { instance, .. } => instance,
        WorkItem::ActivityCompleted { instance, .. } => instance,
        // ... 11+ variants
    };

PROBLEM:
âœ— Provider must know all WorkItem structures
âœ— Pattern matching on 11+ variants

SHOULD BE:
âœ“ WorkItem has instance() method
âœ“ Or: All WorkItems have common instance field
âœ“ Provider doesn't pattern match

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SUMMARY OF VIOLATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Provider SHOULD only know:
  âœ“ How to store opaque events
  âœ“ How to enqueue/dequeue messages
  âœ“ How to provide ACID guarantees
  âœ“ How to implement peek-lock semantics

Provider SHOULD NOT know:
  âœ— What "OrchestrationCompleted" means (knows it)
  âœ— How to create orchestration events (does it)
  âœ— When to create new executions (decides it)
  âœ— What status values mean (uses them)
  âœ— Orchestration names and versions (stores and inspects)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RECOMMENDED IMMEDIATE FIX
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Move event inspection from Provider to Runtime:

BEFORE (in Provider):
    for event in &history_delta {
        match event {
            Event::OrchestrationCompleted { output, .. } => update_status()
        }
    }

AFTER (in Runtime):
    let metadata = self.compute_execution_metadata(&history_delta);
    provider.ack_with_metadata(token, history, items, metadata);
    
(in Provider):
    async fn ack_with_metadata(metadata: HashMap<String, String>) {
        for (key, value) in metadata {
            UPDATE metadata SET value WHERE key
        }
    }

This single change eliminates the biggest abstraction leak with minimal code changes.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
