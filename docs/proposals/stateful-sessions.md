# Proposal: Stateful Sessions for Orchestration Workers

## Problem Statement

Today, every activity invocation in duroxide is **stateless**: the worker dispatcher fetches a `WorkItem::ActivityExecute`, resolves the handler from the registry, executes it, and discards all in-memory state. The next invocation of the same (or a different) activity starts from scratch.

This is fine for short, self-contained work units (API calls, DB writes, data transforms), but it is a poor fit for workloads that require **expensive initialization before they can do useful work**:

| Workload | Init Cost | Per-Invocation Cost |
|----------|-----------|---------------------|
| ML inference (load model weights) | 10–60s, GBs of VRAM | 50–500ms |
| Embedding generation (load tokenizer + model) | 5–30s | 10–100ms |
| Cache warming (load reference data into memory) | 2–30s | <1ms lookup |
| GPU pipeline setup (compile shaders, allocate buffers) | 5–20s | ms-level |
| Database connection pool (TLS handshake, auth) | 1–5s | <1ms query |
| WASM runtime (compile + instantiate module) | 1–10s | <1ms call |

Without sessions, users are forced into workarounds:
1. **Pay init cost on every call** — unacceptable for latency-sensitive ML inference.
2. **Externalize state management** — manage a sidecar process, shared memory, or external service, defeating the purpose of having an orchestration framework.
3. **Abuse long-running activities** — pack an entire inference loop into one activity that never returns, losing orchestration visibility and replay guarantees.

### Motivating Example

An orchestration that classifies 1000 documents:

```rust
// Today: model loaded 1000 times (!)
async fn classify_docs(ctx: OrchestrationContext, docs: Vec<String>) -> Result<Vec<String>, String> {
    let mut results = Vec::new();
    for doc in docs {
        // Each call: load model (30s) + classify (100ms)
        let label = ctx.schedule_activity("Classify", doc).await?;
        results.push(label);
    }
    Ok(results)
}
```

With sessions, the model loads **once** and persists across all 1000 invocations:

```rust
async fn classify_docs(ctx: OrchestrationContext, docs: Vec<String>) -> Result<Vec<String>, String> {
    let session = ctx.open_session("ml-classifier").await;
    let mut results = Vec::new();
    for doc in docs {
        // First call: load model (30s) + classify (100ms)
        // Subsequent calls: classify (100ms) — model already loaded
        let label = session.schedule_activity("Classify", doc).await?;
        results.push(label);
    }
    session.close().await;
    Ok(results)
}
```

---

## Design Goals

1. **Worker-affinity**: Once a session is opened, all its activity invocations route to the same worker so they can share in-process state.
2. **Transparent to the Provider**: Sessions are a runtime + registry concept. The Provider sees normal `WorkItem::ActivityExecute` messages (possibly with routing hints); no schema changes required.
3. **Replay-safe**: `open_session` and `close_session` are deterministic operations recorded in history. Replaying an orchestration that used sessions produces the same scheduling decisions.
4. **Graceful lifecycle**: Sessions have explicit open/close semantics with idle timeouts. Workers release session resources automatically on timeout, orchestration completion, or shutdown.
5. **Composable with existing primitives**: Sessions work alongside regular activities, timers, sub-orchestrations, `select`, `join`, etc.

### Non-Goals (Phase 1)

- **Cross-worker sessions** (distributed shared state) — Phase 1 targets single-worker affinity.
- **Session migration** (move a session from one worker to another) — future work.
- **Automatic session reuse across orchestrations** — sessions are scoped to a single orchestration instance.

---

## Core Concepts

### Session

A **session** is a named, long-lived execution context on a specific worker. It has:

- **Session ID**: Unique identifier (generated by the runtime, deterministic via replay).
- **Session Type**: A string name that maps to a `SessionHandler` in the registry (e.g., `"ml-classifier"`, `"embedding-engine"`).
- **Worker Affinity**: The worker that hosts this session. All activity invocations on the session route to this worker.
- **Lifecycle**: `Created → Active → Closing → Closed`. Idle timeout evicts sessions that are no longer receiving work.
- **User State**: Opaque, in-memory state owned by the `SessionHandler` (e.g., loaded model weights, connection pool, cache).

### SessionHandler

A user-defined trait that manages session lifecycle and handles activities within the session:

```rust
#[async_trait]
pub trait SessionHandler: Send + Sync + 'static {
    /// Called once when the session is created on a worker.
    /// Use this to load models, warm caches, establish connections, etc.
    ///
    /// The returned value is an opaque state object that will be passed
    /// to `invoke` on each activity call.
    async fn init(&self, ctx: SessionInitContext) -> Result<Box<dyn SessionState>, String>;

    /// Called to execute an activity within the session.
    /// `state` is the long-lived state returned by `init`.
    async fn invoke(
        &self,
        state: &mut dyn SessionState,
        ctx: ActivityContext,
        activity_name: &str,
        input: String,
    ) -> Result<String, String>;

    /// Called when the session is being closed (explicit close or idle timeout).
    /// Use this to release resources (unload model, close connections, etc.).
    async fn shutdown(&self, state: Box<dyn SessionState>) {
        drop(state); // Default: just drop
    }

    /// Maximum idle time before the session is automatically evicted.
    /// Default: 5 minutes.
    fn idle_timeout(&self) -> Duration {
        Duration::from_secs(300)
    }
}

/// Marker trait for session state. Must be Send so it can live across await points.
pub trait SessionState: Send + Any {
    fn as_any(&self) -> &dyn Any;
    fn as_any_mut(&self) -> &mut dyn Any;
}
```

### Session Registry

Sessions are registered alongside activities, using a new builder method:

```rust
let activities = ActivityRegistry::builder()
    // Regular activities (stateless)
    .register("SendEmail", |ctx, input| async move { /* ... */ })
    // Session-backed activities
    .register_session("ml-classifier", MlClassifierSession::new("model-path"))
    .build();
```

---

## Architecture

### System Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Orchestration Dispatcher                        │
│                                                                      │
│  Orchestration code calls:                                           │
│    let session = ctx.open_session("ml-classifier").await;           │
│    let result = session.schedule_activity("Classify", doc).await?;  │
│    session.close().await;                                            │
│                                                                      │
│  Replay engine records:                                              │
│    SessionOpened { session_id, session_type, worker_id }             │
│    ActivityScheduled { session_id, ... }                             │
│    SessionClosed { session_id }                                      │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               │  WorkItem::ActivityExecute
                               │  (with session_id routing hint)
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         Worker Dispatcher                            │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐ │
│  │                    Session Manager                                │ │
│  │                                                                   │ │
│  │  ┌──────────────────┐  ┌──────────────────┐                      │ │
│  │  │ session-abc123   │  │ session-def456   │                      │ │
│  │  │ type: ml-class.  │  │ type: embedding  │                      │ │
│  │  │ state: Model{..} │  │ state: Tok{..}   │                      │ │
│  │  │ last_used: T-2s  │  │ last_used: T-30s │                      │ │
│  │  └──────────────────┘  └──────────────────┘                      │ │
│  │                                                                   │ │
│  │  Idle reaper: evicts sessions past idle_timeout                   │ │
│  └─────────────────────────────────────────────────────────────────┘ │
│                                                                      │
│  Worker receives ActivityExecute with session_id:                     │
│    1. Look up session in Session Manager                              │
│    2. If found: call handler.invoke(state, ctx, name, input)         │
│    3. If not found: call handler.init(), cache, then invoke          │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### Event History

Sessions introduce three new event kinds:

```rust
pub enum EventKind {
    // ... existing variants ...

    /// A session was opened on a worker.
    /// Recorded when ctx.open_session() is first executed (not on replay).
    SessionOpened {
        session_id: String,
        session_type: String,
        worker_id: String,
    },

    /// An activity was scheduled within a session.
    /// Functionally identical to ActivityScheduled but carries session_id
    /// for routing.
    // NOTE: We reuse the existing ActivityScheduled event with an optional
    // session_id field to avoid duplicating the entire activity lifecycle.

    /// A session was explicitly closed by the orchestration.
    SessionClosed {
        session_id: String,
    },
}
```

Rather than adding entirely new event kinds, the preferred approach is to extend `ActivityScheduled` with an optional `session_id` field:

```rust
EventKind::ActivityScheduled {
    name: String,
    input: String,
    session_id: Option<String>,  // NEW: if set, route to this session's worker
}
```

This keeps the event model backward-compatible (existing events deserialize with `session_id: None`).

---

## Orchestration Context API

### Opening a Session

```rust
impl OrchestrationContext {
    /// Open a stateful session on a worker.
    ///
    /// The session will be initialized on the first activity call (lazy init).
    /// All activities scheduled through the returned `SessionHandle` are routed
    /// to the same worker, sharing the session's in-memory state.
    ///
    /// Session type must be registered via `ActivityRegistry::register_session()`.
    ///
    /// # Replay Behavior
    ///
    /// On first execution: generates a deterministic session_id, records
    /// `SessionOpened` event, and returns a handle.
    ///
    /// On replay: reads session_id from history, returns a handle that will
    /// replay previous activity results.
    pub async fn open_session(&self, session_type: &str) -> SessionHandle {
        // ...
    }
}
```

### SessionHandle

```rust
/// Handle to an active session. Activities scheduled through this handle
/// are routed to the session's worker for stateful execution.
pub struct SessionHandle {
    session_id: String,
    session_type: String,
    // Internal: reference to OrchestrationContext internals for scheduling
}

impl SessionHandle {
    /// Schedule an activity within this session.
    ///
    /// The activity will execute on the worker hosting this session,
    /// with access to the session's persistent in-memory state.
    pub fn schedule_activity(
        &self,
        activity_name: &str,
        input: impl serde::Serialize,
    ) -> DurableFuture<Result<String, String>> {
        // Internally: schedules ActivityScheduled with session_id set
    }

    /// Explicitly close the session, releasing resources on the worker.
    ///
    /// If not called, the session will be evicted after its idle timeout.
    /// It is good practice to close sessions explicitly.
    pub async fn close(self) {
        // Records SessionClosed event
    }
}
```

### Example Usage

```rust
async fn inference_pipeline(
    ctx: OrchestrationContext,
    documents: Vec<String>,
) -> Result<Vec<String>, String> {
    // Open a session — model will be loaded once on the assigned worker
    let session = ctx.open_session("ml-classifier").await;

    let mut results = Vec::new();
    for doc in documents {
        let label = session.schedule_activity("Classify", doc).await?;
        results.push(label);
    }

    // Explicitly release GPU memory
    session.close().await;

    Ok(results)
}

// Parallel sessions for different models
async fn multi_model_pipeline(ctx: OrchestrationContext, text: String) -> Result<String, String> {
    let classifier = ctx.open_session("ml-classifier").await;
    let embedder = ctx.open_session("embedding-engine").await;

    let label_fut = classifier.schedule_activity("Classify", text.clone());
    let embed_fut = embedder.schedule_activity("Embed", text.clone());

    let (label, embedding) = ctx.join2(label_fut, embed_fut).await;

    classifier.close().await;
    embedder.close().await;

    Ok(format!("label={}, embedding_dim={}", label?, embedding?.len()))
}
```

---

## Worker-Side Implementation

### Session Manager

Each worker maintains a `SessionManager` that tracks active sessions:

```rust
struct SessionManager {
    /// Active sessions keyed by session_id
    sessions: HashMap<String, ActiveSession>,
    /// Session handlers keyed by session_type (from registry)
    handlers: Arc<SessionRegistry>,
}

struct ActiveSession {
    session_id: String,
    session_type: String,
    state: Box<dyn SessionState>,
    last_used: Instant,
    idle_timeout: Duration,
}

impl SessionManager {
    /// Get or create a session for the given ID and type.
    async fn get_or_init(
        &mut self,
        session_id: &str,
        session_type: &str,
        ctx: SessionInitContext,
    ) -> Result<&mut ActiveSession, String> {
        if !self.sessions.contains_key(session_id) {
            let handler = self.handlers.get(session_type)
                .ok_or_else(|| format!("session type '{}' not registered", session_type))?;
            let state = handler.init(ctx).await?;
            self.sessions.insert(session_id.to_string(), ActiveSession {
                session_id: session_id.to_string(),
                session_type: session_type.to_string(),
                state,
                last_used: Instant::now(),
                idle_timeout: handler.idle_timeout(),
            });
        }
        let session = self.sessions.get_mut(session_id).unwrap();
        session.last_used = Instant::now();
        Ok(session)
    }

    /// Close and remove a session, calling shutdown on the handler.
    async fn close(&mut self, session_id: &str) {
        if let Some(session) = self.sessions.remove(session_id) {
            if let Some(handler) = self.handlers.get(&session.session_type) {
                handler.shutdown(session.state).await;
            }
        }
    }

    /// Evict sessions that have exceeded their idle timeout.
    async fn evict_idle(&mut self) {
        let now = Instant::now();
        let expired: Vec<String> = self.sessions.iter()
            .filter(|(_, s)| now.duration_since(s.last_used) > s.idle_timeout)
            .map(|(id, _)| id.clone())
            .collect();
        for id in expired {
            self.close(&id).await;
        }
    }
}
```

### Worker Dispatch Flow (Modified)

The existing `process_next_work_item` function is modified to check for session-routed activities:

```rust
// In worker dispatcher
WorkItem::ActivityExecute { session_id: Some(sid), .. } => {
    // Session-routed activity:
    // 1. Look up session in SessionManager
    // 2. If not found, init session (lazy initialization / session recovery)
    // 3. Call handler.invoke(state, ctx, name, input)
    // 4. Ack result as usual
}

WorkItem::ActivityExecute { session_id: None, .. } => {
    // Regular stateless activity — existing behavior, no change
}
```

---

## Routing: Getting Work to the Right Worker

The key challenge is **routing session-bound activities to the correct worker**. There are several strategies, ordered by implementation complexity:

### Strategy 1: Provider-Level Routing Hint (Recommended for Phase 1)

Extend `WorkItem::ActivityExecute` with an optional `worker_affinity_key`:

```rust
WorkItem::ActivityExecute {
    instance: String,
    execution_id: u64,
    id: u64,
    name: String,
    input: String,
    session_id: Option<String>,           // NEW
    worker_affinity_key: Option<String>,  // NEW: e.g., "worker-0-a1b2"
}
```

**How it works:**
1. When `open_session` executes, the runtime assigns a `worker_id` (the next available worker) and records it in the `SessionOpened` event.
2. Activities scheduled through the session carry this `worker_id` as `worker_affinity_key`.
3. The provider's `fetch_work_item` method uses the affinity key to prefer items routed to this worker.
4. If the affinity worker is unavailable (crashed, shutdown), another worker picks up the item after a timeout and re-initializes the session (graceful degradation).

**Provider changes (minimal):**
```rust
async fn fetch_work_item(
    &self,
    lock_timeout: Duration,
    poll_timeout: Duration,
) -> Result<Option<(WorkItem, String, u32)>, ProviderError>;

// The provider orders work items to prefer those matching the calling worker's ID.
// This can be done via:
//   ORDER BY CASE WHEN worker_affinity_key = ? THEN 0 ELSE 1 END, id ASC
// No schema change needed if affinity key is stored in the serialized WorkItem JSON.
```

**Graceful degradation:** If the affinity worker is down, any worker can pick up the item. The session will be re-initialized (paying the init cost once), and work continues. This avoids a single point of failure.

### Strategy 2: Dedicated Session Queue (Phase 2)

For workloads that need strict affinity guarantees, introduce a per-worker session queue:

```
┌─────────────────────────────────────────────────────────────────┐
│                       Provider Queues                             │
│                                                                   │
│  ┌──────────────────┐   ┌──────────────────────────────────────┐ │
│  │  Worker Queue     │   │  Session Queues (per worker)         │ │
│  │  (stateless)      │   │  ┌─────────────┐ ┌─────────────┐   │ │
│  │  - ActivityExec   │   │  │ worker-0    │ │ worker-1    │   │ │
│  │  - ActivityExec   │   │  │ - Classify  │ │ - Embed     │   │ │
│  │  - ActivityExec   │   │  │ - Classify  │ │ - Embed     │   │ │
│  │                   │   │  └─────────────┘ └─────────────┘   │ │
│  └──────────────────┘   └──────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

This requires provider schema changes and is more complex but provides guaranteed affinity without the "prefer" heuristic.

---

## Replay Semantics

Sessions must be deterministic during replay. Here is how each operation behaves:

| Operation | First Execution | Replay |
|-----------|-----------------|--------|
| `ctx.open_session("ml-classifier")` | Generates session_id, assigns worker, records `SessionOpened` event | Reads session_id and worker_id from history |
| `session.schedule_activity("Classify", input)` | Schedules `ActivityScheduled` with session_id, dispatches to worker | Replays from history (reads `ActivityCompleted`/`ActivityFailed`) |
| `session.close()` | Records `SessionClosed` event, sends close signal to worker | Reads event from history (no-op) |

**Session ID generation** uses the same deterministic ID generation as activities: the session_id is derived from the event_id of the `SessionOpened` event (which is deterministic during replay).

**Worker assignment during replay:** On replay, the worker_id from the original `SessionOpened` event is used. The replay engine does not actually contact the worker — it reads results from history. If the orchestration is replayed after a crash and the original worker is gone, new activity invocations (beyond what's in history) will attempt to use the original worker_id. If that worker is unavailable, the affinity-based routing falls back gracefully.

---

## Failure Modes and Recovery

### Worker Crash During Active Session

1. Worker crashes while session has in-flight activities.
2. Activity lock expires → Provider makes work item visible again.
3. Another worker picks up the item, sees `session_id`.
4. That worker calls `handler.init()` to create a new session locally.
5. Activity executes on the new worker. Init cost is paid once on the new worker.
6. Subsequent activities for this session will route to the new worker (if original worker doesn't recover).

**Key insight:** Session state is **not** durable — it's an optimization (cache). The `SessionHandler::init()` contract is that it can always reconstruct the state from scratch. If a worker dies, the state is rebuilt.

### Orchestration Failure with Open Session

When an orchestration fails or is cancelled while a session is open:
1. The runtime records `SessionClosed` events for all open sessions.
2. Close signals are sent to the worker(s) hosting the sessions.
3. Workers call `handler.shutdown()` to release resources.
4. If the worker is unreachable, the session is evicted by the idle timeout reaper.

### Session Init Failure

If `handler.init()` fails:
1. The activity that triggered the init fails with an infrastructure error.
2. The orchestration can handle the error (retry, fallback, fail).
3. Subsequent calls to the same session will attempt init again.

---

## Configuration

### Runtime Options

```rust
pub struct RuntimeOptions {
    // ... existing options ...

    /// Session configuration.
    /// Default: Sessions disabled (no session registry).
    pub session_config: SessionConfig,
}

pub struct SessionConfig {
    /// Global default idle timeout for sessions.
    /// Individual SessionHandlers can override this.
    /// Default: 5 minutes.
    pub default_idle_timeout: Duration,

    /// Maximum number of concurrent sessions per worker.
    /// Prevents memory exhaustion from too many active sessions.
    /// Default: 32.
    pub max_sessions_per_worker: usize,

    /// How often to check for idle sessions to evict.
    /// Default: 30 seconds.
    pub idle_check_interval: Duration,
}
```

---

## Implementation Phases

### Phase 1: Core Session Lifecycle (MVP)

**Scope:** `open_session`, `schedule_activity`, `close` with soft affinity routing.

1. Add `SessionHandler` and `SessionState` traits.
2. Add `register_session()` to `ActivityRegistryBuilder`.
3. Add `SessionManager` to worker dispatcher.
4. Add `SessionOpened` / `SessionClosed` event kinds.
5. Extend `ActivityScheduled` with optional `session_id`.
6. Extend `WorkItem::ActivityExecute` with optional `session_id` and `worker_affinity_key`.
7. Implement soft-affinity routing in `fetch_work_item` (prefer matching worker).
8. Implement idle timeout eviction in `SessionManager`.
9. Implement `open_session()` and `SessionHandle` on `OrchestrationContext`.
10. Add `SessionConfig` to `RuntimeOptions`.

**Provider changes:** Minimal — the `session_id` and `worker_affinity_key` are serialized inside the `WorkItem` JSON. No schema migration needed. Providers that support ordering hints can optionally optimize `fetch_work_item` to prefer affinity matches.

**Estimated complexity:** Medium. The core machinery (routing, lifecycle) is new but self-contained. The replay engine changes are minimal (new event types, optional field on existing event).

### Phase 2: Strict Affinity & Session Queues

- Per-worker session queues in the provider.
- Guaranteed (not soft) routing to specific workers.
- Session lease renewal (long-lived session lock).
- Provider schema migration for session queue table.

### Phase 3: Advanced Features

- Session migration (move session from one worker to another).
- Session pooling (reuse sessions across orchestration instances for the same session type).
- Session metrics (init time, invocation count, memory usage).
- Typed sessions (`ctx.open_session::<MlClassifier>(config).await`).
- Session-scoped external events (send events to a specific session).

---

## Alternatives Considered

### Alternative 1: Activities-With-State (Stateful Activity Registry)

Instead of a new session concept, allow activity handlers to hold persistent state:

```rust
let classifier = Arc::new(MlClassifier::new("model-path"));
activities.register("Classify", move |ctx, input| {
    let model = classifier.clone();
    async move { model.classify(input).await }
});
```

**Why rejected:** This already works today for global state, but it doesn't solve the routing problem. Two workers both have the model loaded, and there's no affinity — work items bounce between workers randomly. It also doesn't support per-orchestration-instance state or lifecycle management (init/shutdown per logical session).

### Alternative 2: Worker Tags / Labels

Tag workers with capabilities and route activities based on tags:

```rust
let rt = Runtime::start_with_options(store, activities, orchestrations, RuntimeOptions {
    worker_tags: vec!["gpu".into(), "ml-capable".into()],
    ..Default::default()
});
```

**Why deferred (not rejected):** This is complementary to sessions, not a replacement. Tags solve "which worker **can** run this" but not "which worker **should** run this to reuse state." Tags could be a Phase 2 addition that interacts with session placement.

### Alternative 3: Long-Running Activity with Message Channel

Pack the entire inference loop into a single long-running activity:

```rust
activities.register("ClassifyBatch", |ctx, docs: Vec<String>| async move {
    let model = load_model().await;
    let results: Vec<String> = docs.iter().map(|d| model.classify(d)).collect();
    Ok(serde_json::to_string(&results)?)
});
```

**Why rejected:** Loses orchestration visibility (the orchestration sees one black-box activity, not 1000 individual classify steps). No replay granularity — if the activity crashes at document 999, all 1000 must be redone. Doesn't compose with timers, select, or other orchestration patterns.

---

## Open Questions

1. **Session ID determinism:** Should session IDs be derived from the event_id (like activity IDs), or should they be user-provided names? User-provided names allow sharing a session across multiple `open_session` calls, but add complexity.

2. **Multiple orchestrations sharing a session:** Should two different orchestration instances be able to share the same session on a worker? This would require reference counting and more complex lifecycle management.

3. **Session state serialization:** Should we allow optional serialization of session state for debugging/monitoring? This could be a `SessionHandler::snapshot()` method that returns a JSON representation.

4. **Worker selection strategy:** When `open_session` assigns a worker, should it pick the least-loaded worker, a random worker, or allow the user to specify preferences (e.g., "needs GPU")?

5. **Fan-out with sessions:** How should `ctx.join()` interact with sessions? If 100 activities are scheduled through a session, they all route to one worker — that worker becomes the bottleneck. Should we support session pools (N sessions of the same type across N workers)?

6. **Session recovery cost:** If a worker crashes and another picks up the session, the init cost is paid again. For very expensive init (60s model load), should we support session checkpointing to speed up recovery?
